{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"_dll_vendors_d92140e4\"","webpack:///./src/js/index.js","webpack:///delegated ./src/lib/vendor.js from dll-reference _dll_vendors_d92140e4"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_dll_vendors_d92140e4","console","log","_lib_vendor_js__WEBPACK_IMPORTED_MODULE_1__","TEST","hw","helloWorldGenerator","next"],"mappings":"aACA,IAAAA,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,IACAG,EAAAH,EACAI,GAAA,EACAH,YAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,IAAAD,QAAAF,GAGAG,EAAAE,GAAA,EAGAF,EAAAD,QAKAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAZ,EAAAmB,EAAA,SAAAjB,GACAY,OAAAC,eAAAb,EAAA,cAAiDkB,OAAA,KAIjDpB,EAAAqB,EAAA,SAAAlB,GACA,IAAAS,EAAAT,KAAAmB,WACA,WAA2B,OAAAnB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAU,EAAAC,GAAsD,OAAAV,OAAAW,UAAAC,eAAAnB,KAAAgB,EAAAC,IAGtDxB,EAAA2B,EAAA,GAIA3B,IAAA4B,EAAA,wFCnEAzB,EAAAD,QAAA2B,0FCKAC,QAAAC,IAAAC,EAAA,SACAF,QAAAC,IAAAC,EAAA,QAAAC,MAuZA,IAAAC,EANA,YAGA,YAFA,aACA,QACA,SAGAC,GACAL,QAAAC,IAAAG,EAAAE,8BC9ZAjC,EAAAD,QAAAF,EAAA","file":"assets/js/app.6fa03050.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = _dll_vendors_d92140e4;","import \"../css/base.css\";\r\n\r\nimport vendor from \"../lib/vendor.js\"\r\n// import '../learn.txt';\r\n\r\nconsole.log(vendor);\r\nconsole.log(vendor.TEST);\r\nvar html = `\r\n编程风格\r\n块级作用域\r\n字符串\r\n解构赋值\r\n对象\r\n数组\r\n函数\r\nMap 结构\r\nClass\r\n模块\r\n\r\n本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。\r\n\r\n多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 Airbnb 公司的 JavaScript 风格规范。\r\n\r\n块级作用域\r\n（1）let 取代 var\r\n\r\nES6 提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。\r\n\r\n'use strict';\r\n\r\nif (true) {\r\n  let x = 'hello';\r\n}\r\n\r\nfor (let i = 0; i < 10; i++) {\r\n  console.log(i);\r\n}\r\n上面代码如果用var替代let，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var命令做不到这一点。\r\n\r\nvar命令存在变量提升效用，let命令没有这个问题。\r\n\r\n'use strict';\r\n\r\nif (true) {\r\n  console.log(x); // ReferenceError\r\n  let x = 'hello';\r\n}\r\n上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。\r\n\r\n所以，建议不再使用var命令，而是使用let命令取代。\r\n\r\n（2）全局常量和线程安全\r\n\r\n在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。\r\n\r\nconst优于let有几个原因。一个是const可以提醒阅读程序的人，这个变量不应该改变；另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。\r\n\r\n// bad\r\nvar a = 1, b = 2, c = 3;\r\n\r\n// good\r\nconst a = 1;\r\nconst b = 2;\r\nconst c = 3;\r\n\r\n// best\r\nconst [a, b, c] = [1, 2, 3];\r\nconst声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。\r\n\r\n所有的函数都应该设置为常量。\r\n\r\n长远来看，JavaScript 可能会有多线程的实现（比如 Intel 公司的 River Trail 那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。\r\n\r\n字符串\r\n静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。\r\n\r\n// bad\r\nconst a = \"foobar\";\r\nconst b = 'foo' + a + 'bar';\r\n\r\n// acceptable\r\nconst c = \\`\r\nfoobar \\`;\r\n\r\n// good\r\nconst a = 'foobar';\r\nconst b =\\`\r\nfoo$ {\r\n    a\r\n}\r\nbar \\`;\r\nconst c = 'foobar';\r\n解构赋值\r\n使用数组成员对变量赋值时，优先使用解构赋值。\r\n\r\nconst arr = [1, 2, 3, 4];\r\n\r\n// bad\r\nconst first = arr[0];\r\nconst second = arr[1];\r\n\r\n// good\r\nconst [first, second] = arr;\r\n函数的参数如果是对象的成员，优先使用解构赋值。\r\n\r\n// bad\r\nfunction getFullName(user) {\r\n  const firstName = user.firstName;\r\n  const lastName = user.lastName;\r\n}\r\n\r\n// good\r\nfunction getFullName(obj) {\r\n  const { firstName, lastName } = obj;\r\n}\r\n\r\n// best\r\nfunction getFullName({ firstName, lastName }) {\r\n}\r\n如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。\r\n\r\n// bad\r\nfunction processInput(input) {\r\n  return [left, right, top, bottom];\r\n}\r\n\r\n// good\r\nfunction processInput(input) {\r\n  return { left, right, top, bottom };\r\n}\r\n\r\nconst { left, right } = processInput(input);\r\n对象\r\n单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。\r\n\r\n// bad\r\nconst a = { k1: v1, k2: v2, };\r\nconst b = {\r\n  k1: v1,\r\n  k2: v2\r\n};\r\n\r\n// good\r\nconst a = { k1: v1, k2: v2 };\r\nconst b = {\r\n  k1: v1,\r\n  k2: v2,\r\n};\r\n对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。\r\n\r\n// bad\r\nconst a = {};\r\na.x = 3;\r\n\r\n// if reshape unavoidable\r\nconst a = {};\r\nObject.assign(a, { x: 3 });\r\n\r\n// good\r\nconst a = { x: null };\r\na.x = 3;\r\n如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。\r\n\r\n// bad\r\nconst obj = {\r\n  id: 5,\r\n  name: 'San Francisco',\r\n};\r\nobj[getKey('enabled')] = true;\r\n\r\n// good\r\nconst obj = {\r\n  id: 5,\r\n  name: 'San Francisco',\r\n  [getKey('enabled')]: true,\r\n};\r\n上面代码中，对象obj的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。\r\n\r\n另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。\r\n\r\nvar ref = 'some value';\r\n\r\n// bad\r\nconst atom = {\r\n  ref: ref,\r\n\r\n  value: 1,\r\n\r\n  addValue: function (value) {\r\n    return atom.value + value;\r\n  },\r\n};\r\n\r\n// good\r\nconst atom = {\r\n  ref,\r\n\r\n  value: 1,\r\n\r\n  addValue(value) {\r\n    return atom.value + value;\r\n  },\r\n};\r\n数组\r\n使用扩展运算符（...）拷贝数组。\r\n\r\n// bad\r\nconst len = items.length;\r\nconst itemsCopy = [];\r\nlet i;\r\n\r\nfor (i = 0; i < len; i++) {\r\n  itemsCopy[i] = items[i];\r\n}\r\n\r\n// good\r\nconst itemsCopy = [...items];\r\n使用 Array.from 方法，将类似数组的对象转为数组。\r\n\r\nconst foo = document.querySelectorAll('.foo');\r\nconst nodes = Array.from(foo);\r\n函数\r\n立即执行函数可以写成箭头函数的形式。\r\n\r\n(() => {\r\n  console.log('Welcome to the Internet.');\r\n})();\r\n那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。\r\n\r\n// bad\r\n[1, 2, 3].map(function (x) {\r\n  return x * x;\r\n});\r\n\r\n// good\r\n[1, 2, 3].map((x) => {\r\n  return x * x;\r\n});\r\n\r\n// best\r\n[1, 2, 3].map(x => x * x);\r\n箭头函数取代Function.prototype.bind，不应再用 self/_this/that 绑定 this。\r\n\r\n// bad\r\nconst self = this;\r\nconst boundMethod = function(...params) {\r\n  return method.apply(self, params);\r\n}\r\n\r\n// acceptable\r\nconst boundMethod = method.bind(this);\r\n\r\n// best\r\nconst boundMethod = (...params) => method.apply(this, params);\r\n简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。\r\n\r\n所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。\r\n\r\n// bad\r\nfunction divide(a, b, option = false ) {\r\n}\r\n\r\n// good\r\nfunction divide(a, b, { option = false } = {}) {\r\n}\r\n不要在函数体内使用 arguments 变量，使用 rest 运算符（...）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。\r\n\r\n// bad\r\nfunction concatenateAll() {\r\n  const args = Array.prototype.slice.call(arguments);\r\n  return args.join('');\r\n}\r\n\r\n// good\r\nfunction concatenateAll(...args) {\r\n  return args.join('');\r\n}\r\n使用默认值语法设置函数参数的默认值。\r\n\r\n// bad\r\nfunction handleThings(opts) {\r\n  opts = opts || {};\r\n}\r\n\r\n// good\r\nfunction handleThings(opts = {}) {\r\n  // ...\r\n}\r\nMap 结构\r\n注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。\r\n\r\nlet map = new Map(arr);\r\n\r\nfor (let key of map.keys()) {\r\n  console.log(key);\r\n}\r\n\r\nfor (let value of map.values()) {\r\n  console.log(value);\r\n}\r\n\r\nfor (let item of map.entries()) {\r\n  console.log(item[0], item[1]);\r\n}\r\nClass\r\n总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。\r\n\r\n// bad\r\nfunction Queue(contents = []) {\r\n  this._queue = [...contents];\r\n}\r\nQueue.prototype.pop = function() {\r\n  const value = this._queue[0];\r\n  this._queue.splice(0, 1);\r\n  return value;\r\n}\r\n\r\n// good\r\nclass Queue {\r\n  constructor(contents = []) {\r\n    this._queue = [...contents];\r\n  }\r\n  pop() {\r\n    const value = this._queue[0];\r\n    this._queue.splice(0, 1);\r\n    return value;\r\n  }\r\n}\r\n使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。\r\n\r\n// bad\r\nconst inherits = require('inherits');\r\nfunction PeekableQueue(contents) {\r\n  Queue.apply(this, contents);\r\n}\r\ninherits(PeekableQueue, Queue);\r\nPeekableQueue.prototype.peek = function() {\r\n  return this._queue[0];\r\n}\r\n\r\n// good\r\nclass PeekableQueue extends Queue {\r\n  peek() {\r\n    return this._queue[0];\r\n  }\r\n}\r\n模块\r\n首先，Module 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用import取代require。\r\n\r\n// bad\r\nconst moduleA = require('moduleA');\r\nconst func1 = moduleA.func1;\r\nconst func2 = moduleA.func2;\r\n\r\n// good\r\nimport { func1, func2 } from 'moduleA';\r\n使用export取代module.exports。\r\n\r\n// commonJS的写法\r\nvar React = require('react');\r\n\r\nvar Breadcrumbs = React.createClass({\r\n  render() {\r\n    return <nav />;\r\n  }\r\n});\r\n\r\nmodule.exports = Breadcrumbs;\r\n\r\n// ES6的写法\r\nimport React from 'react';\r\n\r\nclass Breadcrumbs extends React.Component {\r\n  render() {\r\n    return <nav />;\r\n  }\r\n};\r\n\r\nexport default Breadcrumbs;\r\n如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用。\r\n\r\n不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。\r\n\r\n// bad\r\nimport * as myObject from './importModule';\r\n\r\n// good\r\nimport myObject from './importModule';\r\n如果模块默认输出一个函数，函数名的首字母应该小写。\r\n\r\nfunction makeStyleGuide() {\r\n}\r\n\r\nexport default makeStyleGuide;\r\n如果模块默认输出一个对象，对象名的首字母应该大写。\r\n\r\nconst StyleGuide = {\r\n  es6: {\r\n  }\r\n};\r\n\r\nexport default StyleGuide;\r\n`;\r\n// let div = document.createElement('div');\r\n// div.innerHTML = html\r\n// document.querySelector(\"body\").appendChild(div)\r\n\r\nfunction* helloWorldGenerator() {\r\n  yield \"hello\";\r\n  yield \"world\";\r\n  return \"ending\";\r\n}\r\n\r\nvar hw = helloWorldGenerator();\r\nconsole.log(hw.next());\r\n","module.exports = (__webpack_require__(\"FnUs\"))(1);"],"sourceRoot":""}